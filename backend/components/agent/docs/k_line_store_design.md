# K 线缓存（k_line_store）设计说明

本文档是「从零重写」k_line_store 的完整设计依据：拓展策略、存储语义、技术选型与路径约定。实现时按此文档来，避免与旧 Datomic 实现混淆。

---

## 1. 问题与目标

- **用户请求**：从某日起 n 条日 K（例如「从 20250101 起 20 条」），不关心具体起止日期，只关心「起始日 + 条数」。
- **难点**：过去某日只有三种状态——(1) 交易日且已缓存 (2) 交易日但未缓存 (3) 非交易日。若不做区分，无法知道「没数据」是缺缓存还是本来就没开市。
- **目标**：缓存后能明确区分「有 K 线」和「已确认非交易日」，且拓展策略简单、存储简单。

---

## 2. 核心思路

### 2.1 每个日历日都有值， 不用区分交易日与非交易日

- 对**已缓存区间内的每一个日历日**都写一条记录。
- **交易日且有 Tushare 数据**：存该日的行数据， 每日一行。
- **非交易日（或该日无数据）**：存一个**占位符**，表示「已缓存，且该日为非交易日」。
  - 占位符在实现里用`-1` 。
- 这样区间内没有「空洞」：只有「有数据」和「占位符」两种，不再混淆 (2)(3)。

### 2.2 日期连续

- 每只股票的缓存的多行，保证涵盖了一个连续的left， right区间。也就是说， 按日期排序的话， 第一条会是left， 最后一条会是right， 总条数应该恰好等于left，right之间（包含left、right）的天数。
  - 拓展策略
    - 当未命中时，总是拓展为： [min(cache_left, user_request_left), today]。
      - 发请求到tushare时， 可以智能的发送： 只需要取“目前范围未覆盖的部分”（实现一个专门的函数来计算这个。），然后逐条添加到数据库里。
    - cronj拓展时， 总是拓展为[cache_left, today]。 如果cache_left不存在， 则设为1year before today.

### 2.3 命中与补缓存逻辑（不依赖「算 end 日期」）

- **起始日**：由于已经把“非交易日”作为状态存储到系统中(-1)， 我们不再需要去计算起始日顺延逻辑。 用户请求从那一天开始，就给这一天的数据。（非交易日数据为-1）
- **是否命中**：
  1. 找到该股当前区间 `[left, right]`。
  2. 若 `start-d` 不在 `[left, right]` 内（在右边或左边），则未命中，需要先拓展再取数。
  3. 若 `start-d` 在区间内：从 `start-d` 起按日历顺序扫，**跳过占位符**，只数「有数据的交易日」；若条数 ≥ n-max，则命中，返回这 n-max 条（按约定顺序，如日期降序）。
  4. 若条数不足，则需拓展（向右到今天或向左到用户日），再重试取数。
- **拓展后**：向右拓展时，新段内每个日历日同样「有数据则存行，无则存占位符」；向左同理。

---

## 3. 存储：SQLite，手写 SQL

- **技术选型**：用 **SQLite** 存 K 线缓存，通过 **next.jdbc** 手写 SQL，不用 HugSQL，不依赖 Datomic。
- **理由**：结构固定、不需 schema 演进、按日期范围检索简单，且单文件/嵌入式，部署简单。

### 3.1 表结构
- **日线表**：按日一条，例如 `(ts_code, trade_date, row_payload)`。
  - `row_payload`：交易日存行数据（如 JSON/EDN 或列拆开）；非交易日存占位符-1。
  - 建议在 `(ts_code, trade_date)` 上建索引，便于按区间查询。

### 3.2 路径与配置

- **环境变量**：`K_LINE_DB_PATH`。若设置，则直接使用（可为文件路径或 `jdbc:sqlite:...` 或 `:memory:`）。
- **未设置时（约定路径，相对项目根目录）**：
  - 生产/开发：`backend/data/sqlite.db`
  - 使用内存库 `jdbc:sqlite::memory:`
- 约定前提：进程从**项目根**启动，使 `user.dir` 为项目根。

---

## 4. Cron（每日任务）

- 在每日 Tushare 更新完成后执行：
  - 对**所有**需要维护的股票：将缓存中**最右边（日期最晚）延展到今天**；新段内每个日历日：有数据写行，无数据写占位符。
  - 若某只股票**还没有任何缓存**：把**一年前的今天**到**今天**拉数，同样逐日填充（有则行，无则占位符）。

---

## 5. 对外 API（保持与现有调用方兼容）

- **get-daily-k-for-multiple-stocks**：对外唯一日 K 接口。`(get-daily-k-for-multiple-stocks codes date-from date-to)`。返回 `[{k-data} ...]`（按 ts_code、trade_date 升序）或 `nil`（未初始化）。`k-data` 含 `:ts_code`、`:trade_date`、`:close` 等及 `:source`（`:cache` 或 `:tushare`）。非交易日占位符已过滤。

---

## 6. 历史数据

- **不做迁移**：旧缓存可直接丢弃，新实现从空库开始；由 Cron 或一次性任务按需拉全量即可。

---

## 7. 实现检查清单（重写时对照）

- [ ] SQLite 建表：日线表，索引 (ts_code, trade_date)。
- [ ] 路径(在k_line_store.clj中配置就行)：读 `K_LINE_DB_PATH`；未设置则用 `backend/data/sqlite.db`（测试用 `:memory:`）。
- [ ] 占位符：非交易日用固定值（-1）与真实行区分；读时过滤掉占位符再计数和返回。
- [ ] 任何股票的所有缓存行的日期保证连续；向右拓展一律到「今天」；向左拓展到用户请求的起始日（当 start-d < left 时）。
- [ ] get-daily-k-for-multiple-stocks：按 codes + date-from + date-to 查缓存，缺段用 ensure-daily-k 补全（Tushare），合并后过滤占位符返回。
- [ ] 实现一个计算“智能拓展区间”的函数。
- [ ] 向tushare发起请求的时候，调用上述函数， 计算需要请求的日期区间。
- [ ] Cron：所有股「右边延展到今天」；无任何数据， 则「一年前今天～今天」。
- [ ] 使用SQLite，不依赖 Datomic。 
- [ ] 设计并实现充分的test，来测试k线cache的功能。

---

*文档版本：供删除旧 k_line_store 后从零实现使用。*
